@charset 'utf-8';

/* main : start */

/* main을 감싸는 container -> main 영역이 알맞게 들어갈 수 있도록, 헤더와 퀵메뉴 크기 뺌 */
.container {
  margin-top: 9rem;
  margin-right: calc(90px - 18px);
  font-size: 1.8rem;
  word-break: keep-all;

  line-height: 1.7;
}

/* section - visual : start */

.visual-section {
  position: relative;
  width: 100%;

  /* 높이도 헤더 영역을 뺴줘야함. -> 헤더의 영역을 뺴줘야 main의 visual 부분이 깔끔하게 스크롤이 생기지 않고 알맞게 들어간다.*/
  height: calc(100vh - 90px);

  /* overflow : hidden을 주어 영역에 벗어나는 것들이 안보이게 한다. -> 알맞게 하기 위해서 방지용 */
  /* hidden을 하면 scroll이 먹히지 않음. 명령을 취소해주고, 다른 영역을 디자인 해야함. -> 이 명령은 다른 이유가 있는 듯함.  */
  /* overflow: hidden; */
}

.visual-section .cover-bg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 10;
  pointer-events: none;

  /*   background: #55f; */
}

.visual-section .cover-bg .cover {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 0%;

  /*   background: #fff; */
}

/* swiper */
.visual-section .swiper-container {
  height: 100%;
}

/* slide에 부모 요소 */
.visual-section .swiper-container .swiper-wrapper {
  position: relative;
  width: 100%;
  height: 100%;
  z-index: 1;

  /* flex를 주면 구현하고자 하는 디자인이 보이지 않기 때문에 일단 명령을 뺴주자 -> swiper에 들어가있는 공통 CSS때문에 안보이는 것 같은데, 디자인을 다 만들고 나서 바꾸자. */
  /*  display: flex; */

  /* border-box는 콘텐츠 영역, 패딩, 테두리까지 포함하여 너비와 높이를 계산. */
  /* 요소의 너비와 높이가 콘텐츠 영역에만 적용 */
  box-sizing: content-box;

  transition-property: transform;
}

/* item이라는 클래스를 붙인 이유는 swiper에 들어가는 공통CSS와 헷갈리지 않게, 다른 클래스에 스타일을 줌. */
.visual-section .item {
  position: relative;
  height: 100%;
}

.visual-section .item .bg {
  position: relative;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
}

.visual-section .item .bg img {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.visual-section .item .txt-box {
  position: absolute;
  top: 30%;
  left: 10%;

  font-size: 5.4rem;
  color: #fff;
}

.visual-section .item .txt-box .tit {
  line-height: 1.4;
}

.visual-section .item .txt-box .tit + .tit {
  font-weight: 700;
}

.visual-section .item .txt-box .txt {
  margin-top: 4.4rem;
  font-size: 2.1rem;
}

.visual-section .item .btn-wrap {
  /* a태그 부모에게 flex를 줘야 공간을 100%을 차지하지 않음. */
  display: flex;
  align-items: center;
  justify-content: flex-start;
  margin-top: 4.6rem;
}

.visual-section .item .btn-wrap a {
  padding: 1.3rem 2rem;

  border: 1px solid #fff;
  border-radius: 2.6rem;

  display: flex;
  align-items: center;
  justify-content: center;

  transition: all 0.5s;
}

.visual-section .item .btn-wrap a .btn-txt {
  font-size: 1.3rem;

  color: #fff;

  margin-right: 1.6rem;
}

.visual-section .item .btn-wrap a .icon {
  display: block;
  width: 1.2rem;
  height: 1.1rem;

  background: url(../img/more-arrow-white.svg) no-repeat 0 0 / cover;
}

.visual-section .item .btn-wrap a:hover {
  background: #fff;
}
.visual-section .item .btn-wrap a:hover .btn-txt {
  color: #000;
}

.visual-section .item .btn-wrap a:hover .icon {
  background: url(../img/more-arrow-black.svg) no-repeat 0 0 / cover;
}

.visual-section .slide-move {
  position: absolute;
  bottom: 15%;
  left: 10%;

  width: 26rem;
  height: 5rem;

  font-size: 1.3rem;

  display: flex;
  align-items: center;
  justify-content: center;
  color: #fff;
  z-index: 10;
}

/* slide 프로그래스 바 */
.visual-section .slide-move .paging {
  display: flex;
  justify-content: flex-end;
  position: absolute;
  top: 50%;
  left: 50%;
  bottom: auto;
  transform: translate(-50%, -50%);

  width: 100%;

  text-align: left;
}

.visual-section .slide-move .paging .timer {
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 0 2rem;

  width: 20rem;
}

.visual-section .slide-move .paging .progress {
  width: 100%;
  height: 2px;

  background: #000;
  opacity: 0.3;
}

.visual-section .slide-move .paging .progress .bar {
  width: 50%;
  height: 2px;

  background: #000;
}

/* 스크롤 다운 아이콘 */
.visual-section .scroll-down {
  position: absolute;
  bottom: 3%;
  left: 50%;
  transform: translate(-50%, 0%);

  text-align: center;
  z-index: 15;
  color: #fff;
}

.visual-section .scroll-down p {
  font-size: 1.3rem;
  font-weight: 700;

  margin-bottom: 1rem;
}

/* 스크롤 마우스 모양 css으로 */
.visual-section .scroll-down .scroll-down-icon span {
  display: block;
  position: relative;
  width: 2.7rem;
  height: 3.6rem;

  border: 1px solid #fff;
  border-radius: 1.3rem;
  box-sizing: border-box;
  /* 가운데로 정렬할 수 있도록. */
  margin: 0 auto;
}

.visual-section .scroll-down .scroll-down-icon span em {
  display: block;
  position: absolute;
  top: 2px;
  width: 4px;
  height: 8px;
  background: #fff;
  border-radius: 3.6rem;

  left: 50%;
  transform: translate(-50%, 0%);

  box-sizing: border-box;

  /* 애니메이션 생성 후 적용 */
  animation: scroll 2s infinite;
}

/* 스크롤 마우스 인터랙션을 위해서 animation 생성 */
@keyframes scroll {
  0% {
    transform: translate(-50%, 0);
    opacity: 0;
  }

  40% {
    opacity: 1;
  }

  80% {
    transform: translate(-50%, 10px);
    opacity: 0;
  }

  100% {
    opacity: 0;
  }
}

/* slide-item에 백그라운드 이미지가 img 태그로 들어가서 다 불러올 수가 없기에, 하나로 여러개를 만듦. */
/* section - visual : end */

/* section - counsel : start */
.counsel-section {
  margin-top: 10rem;
  padding: 5rem 0;

  background-color: #ff5;
  color: #232323;
}

/* 넓이 제한해주는 영역 */
.section-inner {
  position: relative;
  /* max-width에 165.3rem을 주지 않고, width에 주고, max-width에 100%를 준 이유는 width는 기본적으로 폭 넓이를 165.3rem 최대로 갖는다는 의미인데, 넓은 화면에서 레이아웃이 무한히 늘어나는 게 아니라, 최대 디자인 폭이 165.3rem을 유지하도록 만든 것이다. */
  /* max-width는 반응형에 대응하기 위해서 명령을 준 것인데, 만약 width만 165.3rem만 준다면, 화면이 좁아졌을 때도 width는 165.3rem을 고집한다. -> 그러면 스크롤이 생기고, 화면 밖으로 벗어나게 된다. */
  /* max-width:100%를 추가하면 화면이 width의 크기보다 넓을 때는 그대로의 넓이를 유지하고, 화면이 width보다 작아졌을때는 화면 폭에 맞춰 100%로 줄어든다. -> 유동적으로 넓이를 변화하는 구조를 갖게 되는 것이다. */
  width: 165.3rem;
  max-width: 100%;
  margin: 0 auto;

  /* padding을 주는 이유는 잘 모르겠지만. 양끝까지 딱 붙게 하지 않게 하기 위해서라고 한다. 모바일에서는 글자나 이미지가 화면 끝에 딱 붙으면 답답해 보이는 느낌을 주기 때문에 기본적인 가이드로 패딩을 주는 경우가 있다고 한다. */
  padding: 0 2rem;
}

.counsel-section .counsel-container {
  display: flex;

  /* 시작점에 정렬. */
  align-items: flex-start;
  justify-content: space-between;
}

.counsel-section .tit {
  font-size: 2.5rem;
  font-weight: 700;

  /* flex-shrink는 플렉스 아이템이 플렉스 컨테이너의 공간이 부족할 때 줄어드는 비율을 설정하는 속성이다. 기본값은 1이며, 0으로 설정하면 줄어들지 않는다. */
  flex-shrink: 0;

  /*   margin-right: 2.7rem; */
}

/* form태그에 있는 요소들을 grid로 설정. */
/* 이 grid가 만드는 구조는 기본값 grid-auto-flow : row때문에 가로로 채우고 다음줄로 내려간다. */
/* grid-template-columns : max-content  grid-template-columns: max-content max-content; 이므로 두 칸짜리 그리드가 향성되고, 아이템은  1행 1열 - form-box 1행 2열 btn-wrap , 2열 1행은 agree-box*/
/* 여기서 grid-template-columns :max-content는 CSS 그리드 레이아웃에서 컬럼의 너비를 해당 컬럼 내의 컨텐츠가 차지하는 최대 너비만큼 자동 조정하도록 설정하는 기능입니다. 즉, 각 컬럼은 자신의 컨텐츠가 꽉 차도록 자동으로 늘어납니다 */
/* 그렇다면  grid-template-columns: max-content max-content는 두개의 열을 만들고, 각각의 열 너비를 내용이 차지하려는 최댓값으로 딱 맞게 형성하고, 결과적으로 각 열이 내용을 감싸는 최소한의 폭만 차지합니다(늘어나서 빈 공간을 채우려 하지 않음) -> 그로 인해 폼 전체가 “꽉 차는 레이아웃”이 아니라, 컨트롤들이 필요한 만큼만 차지하는 꽉-조인 묶음이 됩니다.*/
/* justify-content : flex-end는 그리드 트랙(열들의 묶음) 전체를 컨테이너의 **가로축 끝(오른쪽)**으로 붙입니다. */
/* 즉 이 구조는 두 열 레이아웃: 왼쪽에 입력 묶음, 오른쪽에 제출 버튼(작은 폭)을 나란히 배치. 내용만큼만 차지: max-content로 둘 다 필요 폭만 사용 → 폼이 “컴팩트”해 보임. 오른쪽 정렬: justify-content: flex-end로 이 컴팩트 묶음을 섹션의 오른쪽에 붙임.  */
.counsel-section .form-wrap {
  display: grid;
  grid-template-columns: max-content max-content;
  justify-content: flex-end;

  /* 세로 가로  (폭) */
  gap: 2rem 3rem;
  width: 100%;
}

/* 데이터 기입란 */
.form-wrap .form-box {
  display: flex;
  align-items: center;
  justify-content: flex-end;
}

.form-wrap .form-box .inp {
  min-width: 20.7rem;
  height: 5.4rem;

  border-bottom: 2px solid #000;
}

/* input태그는 대체 요소이다. 자체 렌더링 규칙을 가지고 있는 요소, 대부분에서 브라우저 텍스트 입력창은 기본적으로 수직 중앙정렬된 텍스트 렌더링 규칙을 가지고 있다. -> 그래서 CSS height를 주면, 그 높이에 맞춰 중앙정렬을 하게 되는 것이다.  */
.form-wrap .form-box .inp input {
  width: 100%;
  height: 100%;
  background: transparent;

  color: #000;
  font-size: 1.7rem;
  font-weight: 500;
}

.form-wrap .form-box .inp + .inp {
  margin-left: 2.8rem;
}

/* 드롭다운 메뉴 박스 -> select태그로 만드는 메뉴 */
.form-wrap .form-box .sel-box {
  min-width: 20.7rem;
  margin-left: 2.8rem;
}

.form-wrap .form-box .sel-box .nice-select {
  height: 5.4rem;

  background-color: transparent;

  border: 0;
  border-radius: 0;
  border-bottom: 2px solid #000;

  font-size: 1.7rem;
  font-weight: 500;
}

/* span에는 저 위에 코드와 같은 명령을 주면 가운데로 정렬하지 않기에, span이 있는 요소에 height를 주고, block이나, flex요소로 만들고, 중앙 정렬을 해주는 명령을 내려야만 중앙정렬이 된댜. */
.form-wrap .form-box .sel-box .nice-select span {
  /* 박스 안 텍스트를 중앙정렬 span인 경우 flex를 하여 공간을 형성 후 중앙 정렬 */
  display: inline-flex;
  align-items: center;
  height: 100%;
}

.form-wrap .form-box .nice-select .list {
  /*   background: #55f; */

  /*스크롤 높이를 제한해준다. */
  max-height: 30.6rem;
  min-width: 100%;
  color: #232313;
  /* overflow : auto는 컨텐츠가 요소의 크기를 초과할 때만 스크롤을 생성한다. -> 자기 영역보다 요소가 크면 스크롤 생성, 요소가 작다면 스크롤 생성 X */
  overflow: auto;
}

/* 아이콘 */
.form-wrap .form-box .nice-select .list:after {
}

/* 드롭다운 메뉴 공통 CSS */
.nice-select {
  line-height: 40px;

  position: relative;
  box-sizing: border-box;

  display: block;
  cursor: pointer;

  font-family: inherit;

  text-align: left !important;
  padding-right: 30px;

  width: auto;
  white-space: nowrap;

  /* 특정 HTML 요소 내의 텍스트 선택을 방지하는 기능입니다. 즉, 사용자가 해당 영역의 텍스트를 드래그하거나 더블 클릭하여 선택할 수 없도록 만듭니다. 주로 텍스트 복사를 방지하거나, 의도치 않은 선택을 막기 위해 사용됩니다.  */
  user-select: none;
}

.nice-select .list {
  background-color: #fff;

  /* 드롭 다운 메뉴 활성화 시 다운 됐을 때에 매뉴 요소의 가독성, 알아보기 위해 */
  box-shadow: 0 0 10px 0 rgba(68, 68, 68, 0.11);

  position: absolute;
  top: calc(100% - 1px);
  left: 0;

  padding: 0;
  margin-top: 0;

  z-index: 9;

  /* 메뉴 활성화 시 opacity 1로 변경 */
  opacity: 0;
  overflow: hidden;

  font-weight: 400;

  /* 메뉴 활성화 시(open) */
  transition: all 0.2s cubic-bezier(0.5, 0, 0, 1.25), opacity 0.15s ease-out;

  /* 마우스에 방해되지 않고, 요소 가라지 않기. */
  pointer-events: none;
}

.nice-select .option {
  line-height: 40px;
  list-style: none;
  min-height: 40px;

  padding: 8.5px 18px;
}

.nice-select .option:hover,
.nice-select .option.focus,
.nice-select .option.selected.focus {
  background-color: #f6f6f6;
}

/* focus 상태일 시 */
.nice-select .option.focus {
}

.nice-select .option.disable {
  color: #999;

  /* 마우스 커서에 걸리지 않게. */
  cursor: default;
}

.nice-select .option.selected {
  font-weight: 700;
}

/* 드롭 다운 메뉴 활성화 시 */

.nice-select.open .list {
  opacity: 1;

  pointer-events: auto;
}

/* 신청 버튼 */
.counsel-section .form-wrap .btn-wrap {
  display: flex;
  align-items: center;
  justify-content: center;
}

.counsel-section .form-wrap .btn-wrap .submit-btn {
  width: 13.2rem;
  height: 5.4rem;

  background-color: #65a9df;
  color: #fff;

  border-radius: 3.4rem;

  transition: background-color 0.3s;
}

.counsel-section .form-wrap .btn-wrap .submit-btn:hover {
  background-color: #0a2e4d;
}

/* 개인정보동의 부분 */
.form-wrap .agree-box {
  display: flex;
  justify-content: flex-end;
  align-items: center;

  font-size: 1.4rem;
}

.form-wrap .agree-box .check-box {
  display: flex;
  align-items: center;
  justify-content: center;
}

/* 개인정보동의 부분에서 check-box안에 있는 input은 사용하지 않기에 display : none을 사용해줘야 크기가 알맞게 들어간다. 사용하지 않으면 크기에 영향을 줘 레이아웃이 틀어진다. */
.form-wrap .agree-box input {
  display: none;
}

.form-wrap .agree-box input:checked + label {
  color: #0c3659;
}

.agree-box .check-box label {
  display: flex;
  align-items: center;
  justify-content: center;

  padding: 0.56rem 1.12rem;

  /* 마우스 커서에 반응 */
  cursor: pointer;

  color: #9a9ea7;

  transition: opacity 0.3s;
}

.agree-box .check-box .icon {
  width: 1.7rem;
  height: 1.7rem;
  background: url(../img/agree-icon.svg) no-repeat 0 0 / contain;

  margin-right: 4px;

  position: relative;

  display: flex;
  align-items: center;
  justify-content: center;
}
.counsel-section .form-wrap .agree-box .btn-wrap {
  margin-left: 7px;

  display: flex;
  align-items: center;
  justify-content: flex-start;
}

.agree-box .btn-wrap .agree-btn {
  position: relative;
  top: -0.3px;

  border-bottom: 1px solid #9a9ea7;

  color: #9a9ea7;

  font-size: 1.3rem;

  padding-bottom: 1px;
  transition: all 0.3s;

  cursor: pointer;
}
/* section - counsel : end */

/* section - staff(조직) : start */
.staff-section {
  padding-top: 12.2rem;
  overflow: hidden;
}

.main-tit-wrap {
  text-align: center;
  width: 100%;
}

.main-tit-wrap .desc {
  font-size: 2.2rem;
  font-weight: 600;
}

.main-tit-wrap .tit {
  font-size: 5.4rem;
  font-weight: 700;

  margin-top: 2.2rem;

  line-height: 1.48;
  letter-spacing: -0.02em;
}

.main-tit-wrap .tit h2 {
}

.main-tit-wrap .tit h2 p {
}

.main-tit-wrap .txt {
  margin-top: 2.6rem;
  font-size: 1.7rem;
  font-weight: 500;

  line-height: 1.82;
}

.main-tit-wrap .txt p {
  display: inline-flex;
  flex-direction: column;
  align-items: center;
}

.main-tit-wrap .txt p span {
  /* 강제로 한줄 맞춤 */
  white-space: nowrap;
}

/* 이미지 영역 */
.staff-section .cont {
  margin: 9rem auto 0;
  width: 80%;
}

.cont .tit {
  font-size: 6.4vw;
  font-weight: 300;

  color: #0c3659;
  opacity: 0.07;

  white-space: nowrap;
  line-height: 1;

  transform: translate(-5%, 50%);
}

.cont .tit:nth-of-type(2) {
  text-align: right;
  /* 텍스트 위치 조정 */
  transform: translate(0, -40%);
}

.cont .img {
  position: relative;
  width: 80%;
  margin: 0 auto;

  z-index: 10;

  transform: scale(0.9);
  transition: opacity 0.8 ease, transform 0.8s ease;

  transform: unset;
}

.cont.active .img {
  transform: unset;
}

.cont .img img {
  width: 100%;
  height: 100%;
  max-width: 100%;

  object-fit: contain;
}

/* section - staff(조직) : end */

/* main : end */
